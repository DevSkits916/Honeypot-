<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Enhanced Device Info Collector</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #090f1c;
      --card: #0f172a;
      --border: rgba(148, 163, 184, 0.12);
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.16);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --success: #34d399;
      --warning: #facc15;
      --danger: #f87171;
      --info: #60a5fa;
      font-size: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.18), transparent 45%),
        radial-gradient(circle at bottom right, rgba(96, 165, 250, 0.18), transparent 45%),
        var(--bg);
      color: var(--text);
      padding: 24px;
      display: flex;
      justify-content: center;
    }

    .page {
      width: min(1200px, 100%);
      display: grid;
      gap: 24px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 20px 40px rgba(8, 47, 73, 0.35);
    }

    h1 {
      margin: 0;
      font-size: clamp(1.6rem, 2.2vw, 2.2rem);
      color: var(--accent);
    }

    .subheading {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 18px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: rgba(59, 130, 246, 0.15);
      color: var(--text);
      transition: transform 0.15s ease, background 0.2s ease;
    }

    button.primary {
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.9), rgba(6, 182, 212, 0.8));
    }

    button.secondary {
      background: rgba(71, 85, 105, 0.45);
    }

    button:hover {
      transform: translateY(-1px);
      background: rgba(59, 130, 246, 0.25);
    }

    button.primary:hover {
      background: linear-gradient(135deg, rgba(59, 130, 246, 1), rgba(45, 212, 191, 0.95));
    }

    .section-title {
      margin: 0 0 16px;
      font-size: 1.2rem;
      font-weight: 700;
      color: #bfdbfe;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }

    .panel {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(15, 23, 42, 0.8));
      border: 1px solid rgba(148, 163, 184, 0.1);
      border-radius: 14px;
      padding: 16px;
      display: grid;
      gap: 6px;
    }

    .panel.highlight {
      border-left: 4px solid rgba(94, 234, 212, 0.85);
      padding-left: 12px;
      background: linear-gradient(180deg, rgba(16, 185, 129, 0.12), rgba(8, 47, 73, 0.6));
    }

    .k {
      font-size: 0.8rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
    }

    .v {
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      color: #f8fafc;
      word-break: break-word;
      line-height: 1.4;
    }

    .status {
      border-radius: 999px;
      padding: 2px 10px;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .status.success { background: rgba(52, 211, 153, 0.18); color: #10b981; }
    .status.warning { background: rgba(250, 204, 21, 0.18); color: #facc15; }
    .status.error { background: rgba(248, 113, 113, 0.2); color: #f87171; }
    .status.info { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }

    .log-card {
      display: grid;
      gap: 16px;
    }

    .log-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 260px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .log-entry {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.12);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 0.8rem;
      display: flex;
      gap: 8px;
      align-items: flex-start;
      line-height: 1.4;
    }

    .log-entry.info { border-left: 4px solid var(--info); }
    .log-entry.success { border-left: 4px solid var(--success); }
    .log-entry.warning { border-left: 4px solid var(--warning); }
    .log-entry.error { border-left: 4px solid var(--danger); }

    .timestamp {
      color: var(--muted);
      font-family: "JetBrains Mono", ui-monospace;
    }

    .message {
      flex: 1;
      color: var(--text);
    }

    .export-box {
      background: rgba(15, 23, 42, 0.75);
      border: 1px dashed rgba(148, 163, 184, 0.45);
      border-radius: 14px;
      padding: 16px;
      font-family: "JetBrains Mono", ui-monospace;
      font-size: 0.8rem;
      color: #cbd5f5;
      max-height: 220px;
      overflow-y: auto;
      white-space: pre-wrap;
      background-image: radial-gradient(circle at top left, rgba(96, 165, 250, 0.14), transparent 60%);
    }

    .footer {
      text-align: center;
      font-size: 0.75rem;
      color: var(--muted);
      line-height: 1.6;
    }

    .advanced-info {
      background: rgba(37, 99, 235, 0.12);
      border: 1px solid rgba(59, 130, 246, 0.22);
      border-radius: 14px;
      padding: 16px;
    }

    .advanced-info ul {
      margin: 12px 0 0;
      padding-left: 18px;
      color: #dbeafe;
      font-size: 0.9rem;
      line-height: 1.5;
    }

    @media (max-width: 720px) {
      body {
        padding: 16px;
      }

      .card {
        padding: 20px;
      }

      .controls {
        flex-direction: column;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <section class="card">
      <h1>üì± Enhanced Device Info Collector</h1>
      <p class="subheading">Gather browser-accessible device, system, and network characteristics with instant logging, export, and optional server capture ‚Äî privacy-first by default.</p>

      <div class="controls" role="group" aria-label="Device info controls">
        <button class="primary" type="button" onclick="collectInfo()">üîÑ Refresh Data</button>
        <button class="secondary" type="button" onclick="exportLogs()">üíæ Export Logs</button>
        <button class="secondary" type="button" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
        <button class="secondary" type="button" onclick="downloadReport()">üìä Download Report</button>
      </div>
    </section>

    <section class="card">
      <h2 class="section-title">üîç Device Identifiers</h2>
      <div class="grid">
        <div class="panel highlight">
          <div class="k">Session ID <span class="status info" id="session-status">Pending</span></div>
          <div class="v" id="sessionId">‚Äî</div>
        </div>
        <div class="panel highlight">
          <div class="k">IMEI / Serial Access <span class="status warning" id="imei-status">Restricted</span></div>
          <div class="v" id="deviceSerial">‚Äî</div>
        </div>
        <div class="panel highlight">
          <div class="k">Hardware Fingerprint <span class="status info" id="fingerprint-status">Pending</span></div>
          <div class="v" id="fingerprint">‚Äî</div>
        </div>
        <div class="panel highlight">
          <div class="k">MAC / Local Network <span class="status warning" id="mac-status">Restricted</span></div>
          <div class="v" id="macAddress">‚Äî</div>
        </div>
      </div>
    </section>

    <section class="card">
      <h2 class="section-title">üíª System Information</h2>
      <div class="grid" id="systemGrid" aria-live="polite"></div>
    </section>

    <section class="card">
      <h2 class="section-title">üåê Network &amp; Connection</h2>
      <div class="grid" id="networkGrid" aria-live="polite"></div>
    </section>

    <section class="card">
      <h2 class="section-title">üîß Hardware &amp; Display</h2>
      <div class="grid" id="hardwareGrid" aria-live="polite"></div>
      <div class="advanced-info" id="advancedInfo">
        <strong style="color:#bfdbfe;">üî¨ Advanced Capabilities</strong>
        <div id="advancedDetails" style="margin-top:10px; color:#dbeafe; font-size:0.9rem;">Collecting details‚Ä¶</div>
      </div>
    </section>

    <section class="card log-card">
      <h2 class="section-title">üìã Activity Log</h2>
      <div class="log-container" id="logContainer" aria-live="polite" aria-label="Activity log"></div>

      <div>
        <h3 class="section-title" style="font-size:1rem; color:#94a3b8; margin-bottom:8px;">Export Data</h3>
        <div class="export-box" id="exportBox">Click ‚ÄúExport Logs‚Äù to generate an exportable JSON snapshot.</div>
      </div>
    </section>

    <footer class="footer">
      <p>‚ö†Ô∏è All data is processed locally in your browser. Nothing is transmitted to external servers unless you explicitly enable the optional <code>saveToServer()</code> call.</p>
      <p>Modern browser APIs ‚Ä¢ Respectful of platform privacy boundaries ‚Ä¢ MIT licensed</p>
    </footer>
  </div>

  <script>
    'use strict';

    const MAX_LOG_ENTRIES = 100;
    const AUTO_SERVER_SAVE_ENABLED = false; // Set to true to automatically POST snapshots to SERVER_ENDPOINT.
    const SERVER_ENDPOINT = '/save-log';
    let serverSaveNoticeShown = false;

    let sessionData = {};
    let logEntries = [];
    let deviceFingerprint = '';

    function setText(id, value) {
      const el = document.getElementById(id);
      if (el) {
        el.textContent = value;
      }
    }

    function updateStatus(id, type, text) {
      const el = document.getElementById(id);
      if (el) {
        el.className = `status ${type}`;
        el.textContent = text;
      }
    }

    function renderLogEntry(entry) {
      const container = document.getElementById('logContainer');
      if (!container) return;

      const wrapper = document.createElement('div');
      wrapper.className = `log-entry ${entry.type}`;

      const time = document.createElement('span');
      time.className = 'timestamp';
      const timeString = new Date(entry.timestamp).toLocaleTimeString();
      time.textContent = `[${timeString}]`;

      const message = document.createElement('span');
      message.className = 'message';
      message.textContent = ` ${entry.message}`;

      wrapper.appendChild(time);
      wrapper.appendChild(message);
      container.appendChild(wrapper);

      while (container.children.length > MAX_LOG_ENTRIES) {
        container.removeChild(container.firstChild);
      }

      container.scrollTop = container.scrollHeight;
    }

    function persistLogs() {
      try {
        localStorage.setItem('deviceInfoLogs', JSON.stringify(logEntries));
      } catch (error) {
        console.warn('Unable to persist logs:', error);
      }
    }

    function log(message, type = 'info') {
      const entry = {
        timestamp: new Date().toISOString(),
        message,
        type,
        sessionId: sessionData.sessionId || null
      };

      logEntries.push(entry);
      if (logEntries.length > MAX_LOG_ENTRIES) {
        logEntries = logEntries.slice(-MAX_LOG_ENTRIES);
      }

      renderLogEntry(entry);
      persistLogs();
    }

    function populateGrid(containerId, items) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = '';

      items.filter(Boolean).forEach(item => {
        const panel = document.createElement('div');
        panel.className = 'panel';

        const key = document.createElement('div');
        key.className = 'k';
        key.textContent = item.label;

        if (item.status) {
          const badge = document.createElement('span');
          badge.className = `status ${item.status.type}`;
          badge.textContent = item.status.text;
          key.appendChild(badge);
        }

        const value = document.createElement('div');
        value.className = 'v';
        value.textContent = item.value;

        panel.appendChild(key);
        panel.appendChild(value);
        container.appendChild(panel);
      });
    }

    function renderAdvancedDetails(details) {
      const container = document.getElementById('advancedDetails');
      if (!container) return;

      container.innerHTML = '';
      if (!details || details.length === 0) {
        container.textContent = 'No additional capabilities detected.';
        return;
      }

      const list = document.createElement('ul');
      details.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        list.appendChild(li);
      });
      container.appendChild(list);
    }

    function generateFingerprint(components) {
      const text = components.filter(Boolean).join('|');
      let hash = 0;
      for (let i = 0; i < text.length; i += 1) {
        hash = (hash << 5) - hash + text.charCodeAt(i);
        hash |= 0; // convert to 32-bit int
      }
      return Math.abs(hash).toString(16).padStart(8, '0');
    }

    function getCanvasFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        if (!ctx) return 'canvas_not_available';

        ctx.fillStyle = '#0ea5e9';
        ctx.fillRect(0, 0, 256, 128);
        ctx.fillStyle = '#fff';
        ctx.font = '16px "Segoe UI"';
        ctx.fillText('Device fingerprint canvas üîç', 8, 24);
        ctx.strokeStyle = '#38bdf8';
        ctx.beginPath();
        ctx.arc(64, 72, 32, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.closePath();

        const gradient = ctx.createLinearGradient(0, 0, 256, 0);
        gradient.addColorStop(0, '#f97316');
        gradient.addColorStop(1, '#6366f1');
        ctx.fillStyle = gradient;
        ctx.fillRect(16, 90, 224, 18);

        return canvas.toDataURL().slice(-32);
      } catch (error) {
        return 'canvas_error';
      }
    }

    function getWebGLFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return 'webgl_not_available';

        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR);
        const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER);
        return `${vendor} | ${renderer}`;
      } catch (error) {
        return 'webgl_error';
      }
    }

    async function attemptIMEIDetection() {
      const details = [];
      try {
        if (window.device && window.device.uuid) {
          details.push(`Cordova device UUID: ${window.device.uuid}`);
        }
        if (window.cordova && window.device && window.device.serial) {
          details.push(`Serial (cordova): ${window.device.serial}`);
        }
        if (navigator.usb) {
          try {
            const devices = await navigator.usb.getDevices();
            if (devices.length > 0) {
              details.push(`USB devices detected: ${devices.length}`);
            }
          } catch (error) {
            details.push('WebUSB available ‚Äî permission required to enumerate.');
          }
        }
        if (/Android/i.test(navigator.userAgent)) {
          details.push('Android browser environment ‚Äî direct IMEI access blocked.');
        }
        if (/(iPhone|iPad|iPod)/i.test(navigator.userAgent)) {
          details.push('iOS browser environment ‚Äî hardware identifiers not exposed.');
        }
      } catch (error) {
        details.push(`Detection error: ${error.message}`);
      }
      if (details.length === 0) {
        return 'No device identifiers accessible (browser security restrictions).';
      }
      return details.join(' ‚Ä¢ ');
    }

    async function attemptMACAddress() {
      if (!window.RTCPeerConnection) {
        return 'MAC address not accessible (no WebRTC support).';
      }

      return new Promise(resolve => {
        try {
          const pc = new RTCPeerConnection({ iceServers: [] });
          const results = [];
          let resolved = false;

          pc.createDataChannel('');
          pc.onicecandidate = event => {
            if (event.candidate) {
              const match = event.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
              if (match && !results.includes(match[1])) {
                results.push(match[1]);
              }
            }
          };

          pc.createOffer().then(offer => pc.setLocalDescription(offer)).catch(() => {
            if (!resolved) {
              resolved = true;
              resolve('MAC address not accessible (permission denied).');
            }
          });

          setTimeout(() => {
            pc.close();
            if (!resolved) {
              resolved = true;
              if (results.length > 0) {
                resolve(`Local IP hints via WebRTC: ${results.join(', ')}`);
              } else {
                resolve('MAC address not accessible (privacy protection).');
              }
            }
          }, 1200);
        } catch (error) {
          resolve(`MAC detection error: ${error.message}`);
        }
      });
    }

    async function collectAdvancedInventory() {
      const summary = [];
      const details = {
        mediaDevices: null,
        storage: null,
        serviceWorkers: null,
        gamepads: null
      };

      try {
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const grouped = devices.reduce((acc, device) => {
            acc[device.kind] = (acc[device.kind] || 0) + 1;
            return acc;
          }, {});
          details.mediaDevices = {
            cameras: grouped.videoinput || 0,
            microphones: grouped.audioinput || 0,
            speakers: grouped.audiooutput || 0,
            total: devices.length
          };
          summary.push(`Media devices ‚Üí ${details.mediaDevices.cameras} camera(s), ${details.mediaDevices.microphones} mic(s), ${details.mediaDevices.speakers} speaker(s).`);
        }
      } catch (error) {
        summary.push(`Media device lookup error: ${error.message}.`);
      }

      try {
        if (navigator.storage && navigator.storage.estimate) {
          const estimate = await navigator.storage.estimate();
          details.storage = {
            quota: estimate.quota || 0,
            usage: estimate.usage || 0,
            usageDetails: estimate.usageDetails || null
          };
          if (estimate.quota) {
            const quotaGB = (estimate.quota / 1024 / 1024 / 1024).toFixed(2);
            const usageMB = (estimate.usage / 1024 / 1024).toFixed(2);
            summary.push(`Storage quota ‚âà ${quotaGB} GB ‚Ä¢ usage ‚âà ${usageMB} MB.`);
          }
        }
      } catch (error) {
        summary.push(`Storage estimation error: ${error.message}.`);
      }

      try {
        if ('serviceWorker' in navigator) {
          const registrations = await navigator.serviceWorker.getRegistrations();
          details.serviceWorkers = registrations.length;
          summary.push(`Service workers registered: ${registrations.length}.`);
        }
      } catch (error) {
        summary.push(`Service worker lookup error: ${error.message}.`);
      }

      try {
        if (navigator.getGamepads) {
          const pads = Array.from(navigator.getGamepads()).filter(Boolean);
          details.gamepads = pads.length;
          if (pads.length > 0) {
            summary.push(`Gamepads connected: ${pads.length}.`);
          }
        }
      } catch (error) {
        summary.push(`Gamepad lookup error: ${error.message}.`);
      }

      return { summary, details };
    }

    function buildExportData() {
      return {
        sessionInfo: sessionData,
        deviceFingerprint,
        logs: logEntries,
        exportTimestamp: new Date().toISOString(),
        summary: {
          totalLogs: logEntries.length,
          sessionDurationMs: logEntries.length > 1
            ? new Date(logEntries[logEntries.length - 1].timestamp).getTime() - new Date(logEntries[0].timestamp).getTime()
            : 0
        }
      };
    }

    async function saveToServer(payload) {
      if (!AUTO_SERVER_SAVE_ENABLED) {
        if (!serverSaveNoticeShown) {
          serverSaveNoticeShown = true;
          log('Server save disabled. Set AUTO_SERVER_SAVE_ENABLED to true to POST snapshots to /save-log.', 'info');
        }
        return { ok: false, skipped: true };
      }

      if (!navigator.onLine) {
        log('Skipping server save ‚Äî browser reported offline state.', 'warning');
        return { ok: false, skipped: true };
      }

      try {
        const response = await fetch(SERVER_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error(`${response.status} ${response.statusText}`.trim());
        }

        log('Session snapshot successfully transmitted to server.', 'success');
        return { ok: true };
      } catch (error) {
        log(`Server save failed: ${error.message}`, 'error');
        return { ok: false, error };
      }
    }

    async function collectInfo() {
      log('üîÑ Starting device, system, and network collection‚Ä¶', 'info');

      sessionData = {
        sessionId: '',
        collectedAt: new Date().toISOString()
      };

      setText('sessionId', 'Generating‚Ä¶');
      updateStatus('session-status', 'info', 'Generating‚Ä¶');
      updateStatus('fingerprint-status', 'info', 'Generating‚Ä¶');
      updateStatus('imei-status', 'warning', 'Restricted');
      updateStatus('mac-status', 'warning', 'Restricted');

      try {
        sessionData.sessionId = (globalThis.crypto && globalThis.crypto.randomUUID)
          ? crypto.randomUUID()
          : `session_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
        setText('sessionId', sessionData.sessionId);
        updateStatus('session-status', 'success', 'Active');

        sessionData.userAgent = navigator.userAgent || 'Unavailable';
        sessionData.platform = navigator.platform || 'Unavailable';
        sessionData.languages = (navigator.languages && navigator.languages.length > 0)
          ? navigator.languages.join(', ')
          : navigator.language || 'Unavailable';
        sessionData.cookieEnabled = navigator.cookieEnabled;
        sessionData.onLine = navigator.onLine;
        sessionData.doNotTrack = navigator.doNotTrack || 'unspecified';

        sessionData.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown';
        sessionData.timezoneOffsetMinutes = new Date().getTimezoneOffset();

        if (navigator.userAgentData && navigator.userAgentData.getHighEntropyValues) {
          try {
            const highEntropy = await navigator.userAgentData.getHighEntropyValues([
              'architecture', 'model', 'platformVersion', 'uaFullVersion'
            ]);
            sessionData.userAgentData = {
              mobile: navigator.userAgentData.mobile,
              platform: navigator.userAgentData.platform,
              brands: navigator.userAgentData.brands || [],
              ...highEntropy
            };
          } catch (error) {
            sessionData.userAgentData = { error: error.message };
          }
        }

        const screenInfo = window.screen || {};
        sessionData.screenResolution = `${screenInfo.width || 'na'} √ó ${screenInfo.height || 'na'}`;
        sessionData.availableScreen = (screenInfo.availWidth && screenInfo.availHeight)
          ? `${screenInfo.availWidth} √ó ${screenInfo.availHeight}`
          : 'Unavailable';
        sessionData.viewport = `${window.innerWidth} √ó ${window.innerHeight}`;
        sessionData.colorDepth = screenInfo.colorDepth ? `${screenInfo.colorDepth}-bit` : 'Unknown';
        sessionData.pixelRatio = window.devicePixelRatio || 1;

        sessionData.hardwareConcurrency = navigator.hardwareConcurrency || 'Unknown';
        sessionData.deviceMemory = typeof navigator.deviceMemory === 'number'
          ? `${navigator.deviceMemory} GB`
          : 'Unknown';
        sessionData.maxTouchPoints = navigator.maxTouchPoints || 0;

        sessionData.canvasFingerprint = getCanvasFingerprint();
        sessionData.webglFingerprint = getWebGLFingerprint();
        deviceFingerprint = generateFingerprint([
          sessionData.userAgent,
          sessionData.screenResolution,
          sessionData.timezone,
          sessionData.languages,
          sessionData.hardwareConcurrency,
          sessionData.deviceMemory,
          sessionData.platform,
          sessionData.canvasFingerprint,
          sessionData.webglFingerprint
        ]);
        setText('fingerprint', deviceFingerprint);
        updateStatus('fingerprint-status', 'success', 'Generated');

        sessionData.connectionInfo = { status: 'Unavailable' };
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection) {
          sessionData.connectionInfo = {
            effectiveType: connection.effectiveType || 'unknown',
            downlink: typeof connection.downlink === 'number' ? connection.downlink : null,
            rtt: typeof connection.rtt === 'number' ? connection.rtt : null,
            saveData: Boolean(connection.saveData),
            type: connection.type || 'unknown'
          };
        }

        if (navigator.getBattery) {
          try {
            const battery = await navigator.getBattery();
            sessionData.battery = {
              level: `${Math.round(battery.level * 100)}%`,
              charging: battery.charging,
              chargingTime: battery.chargingTime,
              dischargingTime: battery.dischargingTime
            };
          } catch (error) {
            sessionData.battery = { error: error.message };
          }
        }

        sessionData.deviceSerial = await attemptIMEIDetection();
        setText('deviceSerial', sessionData.deviceSerial);
        if (/restricted|not accessible|blocked/i.test(sessionData.deviceSerial)) {
          updateStatus('imei-status', 'warning', 'Restricted');
        } else if (/error/i.test(sessionData.deviceSerial)) {
          updateStatus('imei-status', 'error', 'Error');
        } else {
          updateStatus('imei-status', 'success', 'Detected');
        }

        sessionData.macHints = await attemptMACAddress();
        setText('macAddress', sessionData.macHints);
        if (/not accessible|privacy/i.test(sessionData.macHints)) {
          updateStatus('mac-status', 'warning', 'Restricted');
        } else if (/error/i.test(sessionData.macHints)) {
          updateStatus('mac-status', 'error', 'Error');
        } else {
          updateStatus('mac-status', 'info', 'Hints');
        }

        const advanced = await collectAdvancedInventory();
        sessionData.advancedSummary = advanced.summary;
        sessionData.advancedDetails = advanced.details;
        renderAdvancedDetails(advanced.summary);

        sessionData.storageEstimate = advanced.details.storage || null;
        sessionData.mediaDevices = advanced.details.mediaDevices || null;
        sessionData.serviceWorkers = advanced.details.serviceWorkers;
        sessionData.gamepads = advanced.details.gamepads;

        populateGrid('systemGrid', [
          { label: 'User Agent', value: sessionData.userAgent },
          { label: 'Platform', value: sessionData.platform },
          sessionData.userAgentData ? {
            label: 'User Agent Data',
            value: `Mobile: ${sessionData.userAgentData.mobile ?? 'n/a'} ‚Ä¢ Platform: ${sessionData.userAgentData.platform ?? 'n/a'}`
          } : null,
          { label: 'Languages', value: sessionData.languages },
          {
            label: 'Timezone',
            value: `${sessionData.timezone} (UTC${sessionData.timezoneOffsetMinutes > 0 ? '-' : '+'}${Math.abs(sessionData.timezoneOffsetMinutes / 60)}h)`
          },
          {
            label: 'Privacy Flags',
            value: `Do Not Track: ${sessionData.doNotTrack} ‚Ä¢ Cookies: ${sessionData.cookieEnabled ? 'enabled' : 'disabled'} ‚Ä¢ Online: ${sessionData.onLine ? 'yes' : 'no'}`
          }
        ]);

        populateGrid('networkGrid', [
          {
            label: 'Effective Connection',
            value: connection ? connection.effectiveType || 'unknown' : 'Not available'
          },
          connection ? {
            label: 'Downlink',
            value: connection.downlink ? `${connection.downlink} Mbps` : 'Not reported'
          } : null,
          connection ? {
            label: 'Round-Trip Time',
            value: connection.rtt ? `${connection.rtt} ms` : 'Not reported'
          } : null,
          connection ? {
            label: 'Save-Data Mode',
            value: connection.saveData ? 'Enabled' : 'Disabled or not reported'
          } : null,
          connection ? {
            label: 'Connection Type',
            value: connection.type || 'Not reported'
          } : null,
          { label: 'Local Network Hints', value: sessionData.macHints }
        ]);

        const storageEstimate = sessionData.storageEstimate;
        const storageValue = storageEstimate && storageEstimate.quota
          ? `${(storageEstimate.usage / 1024 / 1024).toFixed(2)} MB used of ${(storageEstimate.quota / 1024 / 1024 / 1024).toFixed(2)} GB`
          : 'Not available';

        const batteryInfo = sessionData.battery
          ? (sessionData.battery.error
            ? `Battery status unavailable (${sessionData.battery.error})`
            : `${sessionData.battery.level} ‚Ä¢ Charging: ${sessionData.battery.charging ? 'yes' : 'no'}`)
          : 'Not reported';

        populateGrid('hardwareGrid', [
          { label: 'Screen Resolution', value: sessionData.screenResolution },
          { label: 'Available Screen', value: sessionData.availableScreen },
          { label: 'Viewport Size', value: sessionData.viewport },
          { label: 'Color Depth', value: sessionData.colorDepth },
          { label: 'Device Pixel Ratio', value: sessionData.pixelRatio.toString() },
          { label: 'CPU Cores', value: sessionData.hardwareConcurrency.toString() },
          { label: 'Reported Memory', value: sessionData.deviceMemory },
          { label: 'Max Touch Points', value: sessionData.maxTouchPoints.toString() },
          { label: 'Canvas Fingerprint Tail', value: sessionData.canvasFingerprint },
          { label: 'WebGL Renderer', value: sessionData.webglFingerprint },
          { label: 'Battery Status', value: batteryInfo },
          { label: 'Storage Estimate', value: storageValue },
          sessionData.mediaDevices ? {
            label: 'Media Devices',
            value: `${sessionData.mediaDevices.total} total (üé• ${sessionData.mediaDevices.cameras}, üéôÔ∏è ${sessionData.mediaDevices.microphones}, üîà ${sessionData.mediaDevices.speakers})`
          } : null,
          typeof sessionData.serviceWorkers === 'number' ? {
            label: 'Registered Service Workers',
            value: sessionData.serviceWorkers.toString()
          } : null,
          typeof sessionData.gamepads === 'number' ? {
            label: 'Connected Gamepads',
            value: sessionData.gamepads.toString()
          } : null
        ]);

        log('‚úÖ Device information collection completed.', 'success');

        const exportPayload = buildExportData();
        await saveToServer(exportPayload);
      } catch (error) {
        console.error('Collection error:', error);
        log(`‚ùå Error during collection: ${error.message}`, 'error');
      }
    }

    function exportLogs() {
      const exportData = buildExportData();
      const exportBox = document.getElementById('exportBox');
      if (exportBox) {
        exportBox.textContent = JSON.stringify(exportData, null, 2);
      }
      log('üì§ Export generated in-page.', 'info');
      return exportData;
    }

    function clearLogs() {
      if (!confirm('Clear all stored log entries? This cannot be undone.')) {
        return;
      }
      logEntries = [];
      const container = document.getElementById('logContainer');
      if (container) {
        container.innerHTML = '';
      }
      persistLogs();
      const exportBox = document.getElementById('exportBox');
      if (exportBox) {
        exportBox.textContent = 'Logs cleared. Click ‚ÄúExport Logs‚Äù to generate fresh data.';
      }
      log('üóëÔ∏è Log history cleared by user.', 'warning');
    }

    function downloadReport() {
      const exportData = exportLogs();
      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = `device-info-report-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      URL.revokeObjectURL(url);
      log('üíæ JSON report downloaded.', 'success');
    }

    function loadStoredLogs() {
      try {
        const stored = JSON.parse(localStorage.getItem('deviceInfoLogs') || '[]');
        if (Array.isArray(stored) && stored.length > 0) {
          logEntries = stored.slice(-MAX_LOG_ENTRIES);
          logEntries.forEach(entry => renderLogEntry(entry));
        }
      } catch (error) {
        console.warn('Unable to read stored logs:', error);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      loadStoredLogs();
      collectInfo();
    });
  </script>
</body>
</html>
